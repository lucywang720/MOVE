# import numpy as np
# from gym.spaces import Box
# from scipy.spatial.transform import Rotation

# from metaworld.envs import reward_utils
# from metaworld.envs.asset_path_utils import full_v2_path_for
# from metaworld.envs.mujoco.sawyer_xyz.sawyer_xyz_env import SawyerXYZEnv, _assert_task_is_set
# from scipy.stats import beta


# class SawyerPickPlaceLineEnvV2(SawyerXYZEnv):
#     """
#     Motivation for V2:
#         V1 was very difficult to solve because the observation didn't say where
#         to move after picking up the puck.
#     Changelog from V1 to V2:
#         - (7/7/20) Removed 3 element vector. Replaced with 3 element position
#             of the goal (for consistency with other environments)
#         - (6/15/20) Added a 3 element vector to the observation. This vector
#             points from the end effector to the goal coordinate.
#             i.e. (self._target_pos - pos_hand)
#         - (6/15/20) Separated reach-push-pick-place into 3 separate envs.
#     """
#     def __init__(self):
#         goal_low = (-0.1, 0.8, 0.05)
#         goal_high = (0.1, 0.9, 0.3)
#         hand_low = (-0.5, 0.40, 0.05)
#         hand_high = (0.5, 1, 0.5)
#         obj_low = (-0.2, 0.5, 0.02)
#         obj_high = (0.1, 0.8, 0.02)

#         self.goal_low = goal_low
#         self.goal_high = goal_high
#         self.obj_low = obj_low
#         self.obj_high = obj_high

#         if obj_low[1] == 0.55 and obj_low[0] == -0.2:#3*2
#             self.obj_x = [-0.2, -0.125, -0.05, 0.025, 0.1]
#             self.obj_y = [0.55, 0.64, 0.7, 0.75]
#         elif obj_low[1] == 0.55 and obj_low[0] == -0.1:#2*2
#             self.obj_x = [-0.1, -0.05, 0.0, 0.05, 0.1]
#             self.obj_y = [0.55, 0.64, 0.7, 0.75]
#         elif obj_low[1] == 0.6 and obj_low[0] == -0.2:#3*1
#             self.obj_x = [-0.2, -0.125, -0.05, 0.025, 0.1]
#             self.obj_y = [0.6, 0.63, 0.66, 0.7]
#         elif obj_low[1] == 0.6 and obj_low[0] == -0.1:#3*1
#             self.obj_x = [-0.1, -0.05, 0.0, 0.05, 0.1]
#             self.obj_y = [0.6, 0.63, 0.66, 0.7]
#         else:
#             # self.obj_x = [-0.2, -0.125, -0.025, 0.05, 0.1]
#             # self.obj_y = [0.5, 0.6, 0.7, 0.8]
#             self.obj_x = [-0.18, -0.115, -0.05, 0.015, 0.08]
#             self.obj_y = [0.52, 0.607, 0.693, 0.78]

#         # obj_low = (-0.2, 0.5, 0.02)
#         # obj_high = (0.1, 0.8, 0.02)
#         self.obj_x = [-0.2+0.3/21*i for i in range(1,21)]
#         self.obj_y = [0.5+0.3/21*i for i in range(1,21)]

#         # goal_low = (-0.1, 0.8, 0.05)
#         # goal_high = (0.1, 0.9, 0.3)
#         self.goal_points = [(0, 0.85, 0.175)]

#         self.obj_initial_cnt = 0

#         super().__init__(
#             self.model_name,
#             hand_low=hand_low,
#             hand_high=hand_high,
#         )

#         self.move_object = True
#         self.retarget = False

#         self.init_config = {
#             'obj_init_angle': .3,
#             'obj_init_pos': np.array([0, 0.6, 0.02]),
#             'hand_init_pos': np.array([0, .6, .2]),
#         }

#         self.goal = np.array([0.1, 0.8, 0.2])

#         self.obj_init_angle = self.init_config['obj_init_angle']
#         self.obj_init_pos = self.init_config['obj_init_pos']
#         self.hand_init_pos = self.init_config['hand_init_pos']
#         self._target_pos = self.goal.copy()

#         self._random_reset_space = Box(
#             np.hstack((obj_low, goal_low)),
#             np.hstack((obj_high, goal_high)),
#         )
#         self.goal_space = Box(np.array(goal_low), np.array(goal_high))


#         self.num_resets = 0
#         # self.obj_init_pos = None

#     @property
#     def model_name(self):
#         return full_v2_path_for('sawyer_xyz/sawyer_pick_place_v2.xml')

#     @_assert_task_is_set
#     def evaluate_state(self, obs, action):
#         obj = obs[4:7]

#         reward, tcp_to_obj, tcp_open, obj_to_target, grasp_reward, in_place_reward = self.compute_reward(action, obs)
#         success = float(obj_to_target <= 0.07)
#         near_object = float(tcp_to_obj <= 0.03)
#         grasp_success = float(self.touching_main_object and (tcp_open > 0) and (obj[2] - 0.02 > self.obj_init_pos[2]))
#         info = {
#             'success': success,
#             'near_object': near_object,
#             'grasp_success': grasp_success,
#             'grasp_reward': grasp_reward,
#             'in_place_reward': in_place_reward,
#             'obj_to_target': obj_to_target,
#             'unscaled_reward': reward
#         }

#         # print(obs.shape, action.shape, info)

#         return reward, info

#     @property
#     def _get_id_main_object(self):
#         return self.unwrapped.model.geom_name2id('objGeom')

#     def _get_pos_objects(self):
#         return self.get_body_com('obj')

#     def _get_quat_objects(self):
#         return Rotation.from_matrix(self.data.get_geom_xmat('objGeom')).as_quat()

#     def fix_extreme_obj_pos(self, orig_init_pos):
#         # This is to account for meshes for the geom and object are not
#         # aligned. If this is not done, the object could be initialized in an
#         # extreme position
#         diff = self.get_body_com('obj')[:2] - \
#                self.get_body_com('obj')[:2]
#         adjusted_pos = orig_init_pos[:2] + diff
#         # The convention we follow is that body_com[2] is always 0,
#         # and geom_pos[2] is the object height
#         return [
#             adjusted_pos[0],
#             adjusted_pos[1],
#             self.get_body_com('obj')[-1]
#         ]

#     def reset_model(self, set_xyz=False):

#         self._reset_hand()

#         if set_xyz:
#         # if False:
#             self._target_pos = self.goal.copy()
#             # print(type(self._target_pos), type(self.obj_init_pos))
#             # self.obj_init_pos = self.fix_extreme_obj_pos(self.init_config['obj_init_pos'])
#             self.obj_init_angle = self.init_config['obj_init_angle']

#             # print("into set xyz")

#             if self.random_init:
#                 self.obj_init_pos = np.array([-0.05, 0.65, 0.02])
#                 self._target_pos = np.array([0, 0.85, 0.175])

#             else:
#                 self.obj_initial_cnt += 1
#                 self.obj_init_pos = [self.obj_x[(self.obj_initial_cnt-1)%20], self.obj_y[(self.obj_initial_cnt-1)%20], 0.02]
#                 self._target_pos = np.array(list(self.goal_points[0]))


#         else:
#             self._target_pos = self._target_pos
#             # self._target_pos = self.goal.copy()
#             # print(type(self._target_pos), type(self.obj_init_pos))
#             self.obj_init_pos = self.fix_extreme_obj_pos(self.obj_init_pos)
#             self.obj_init_angle = self.init_config['obj_init_angle']

#         self.init_tcp = self.tcp_center
#         self.init_left_pad = self.get_body_com('leftpad')
#         self.init_right_pad = self.get_body_com('rightpad')
#         self._set_obj_xyz(self.obj_init_pos)
#         self.num_resets += 1

#         return self._get_obs()

#     def set_new_target(self, state=None):
#         print(state)
#         print(state!=None)
#         if not (state is None):
#             self._target_pos = state
#             return
#         while True:
#             print("reset target", self._target_pos)
#             tmp = np.array([
#                 np.random.uniform(self.goal_low[0], self.goal_high[0]),  # 第一个元素：[-0.3, 0.3]
#                 np.random.uniform(self.goal_low[1], self.goal_high[1]),   # 第二个元素：[0.6, 0.8]
#                 np.random.uniform(self.goal_low[2], self.goal_high[2])      # 第三个元素：[0, 0.2]
#             ])
#             # if np.linalg.norm(tmp - self._target_pos) >= 0.1:
#             if np.linalg.norm(tmp - self.obj_init_pos) >= 0.33541019662496846/2:# and np.linalg.norm(tmp - self._target_pos) >= 0.1:
#             # if tmp[0] - self.obj_init_pos[0] >= -0.15:# and np.linalg.norm(tmp - self._target_pos) >= 0.1:
#                 self._target_pos = tmp
#                 break


#     # def set_new_obj(self, state=None, v=0, d=None):
#     #     v = -0.01
#     #     # if d[0][0] == -1:
#     #     #     pass
#     #     # else:
#     #     #     d = np.array([[1,1,0]])
#     #     if v != 0:
#     #         self.obj_init_pos = np.clip(self.obj_init_pos+d[0]*v, self.obj_low, self.obj_high)
#     #         # print("target, ", self._target_pos)
#     #         self._set_obj_xyz_move(self.obj_init_pos, target=self._target_pos)
#     #         # print(d)
#     #         if self.obj_init_pos[0] == self.obj_low[0] or self.obj_init_pos[0] == self.obj_high[0]:
#     #             d[0][0] = -d[0][0]
#     #         if self.obj_init_pos[1] == self.obj_low[1] or self.obj_init_pos[1] == self.obj_high[1]:
#     #             d[0][1] = -d[0][1]
#     #         return d
#     #     elif state:
#     #         self.obj_init_pos = np.clip([self.get_body_com('obj')[0]+np.random.randn()*0.06, 0.8 - np.random.rand()*0.05 if self.obj_init_pos[1] >= 0.8 else self.get_body_com('obj')[1]+np.random.rand()*0.005, 0.02], self.obj_low, self.obj_high)
#     #         self._set_obj_xyz(self.obj_init_pos)            
#     #     else:
#     #         while True:
#     #             # print("obj", self.obj_init_pos)
#     #             tmp = np.array([
#     #                 np.random.uniform(self.obj_low[0], self.obj_high[0]),  # 第一个元素：[-0.3, 0.3]
#     #                 np.random.uniform(self.obj_low[1], self.obj_high[1]),   # 第二个元素：[0.6, 0.8]
#     #                 np.random.uniform(self.obj_low[2], self.obj_high[2])      # 第三个元素：[0, 0.2]
#     #             ])
#     #             if np.linalg.norm(tmp - self.obj_init_pos) <= 0.223606797749979/8:
#     #                 self.obj_init_pos = tmp
#     #                 self._set_obj_xyz(self.obj_init_pos)
#     #                 return np.array([[0,0,0]])
#     #                 break     


#     def set_new_obj(self, state=None, v=0, d=None):
#         if v != 0:
#             self.obj_init_pos = np.clip(self.obj_init_pos+d[0]*v, self.obj_low, self.obj_high)
#             # print("target, ", self._target_pos)
#             self._set_obj_xyz_move(self.obj_init_pos, target=self._target_pos)
#             # print(d)
#             if self.obj_init_pos[0] == self.obj_low[0] or self.obj_init_pos[0] == self.obj_high[0]:
#                 d[0][0] = -d[0][0]
#             if self.obj_init_pos[1] == self.obj_low[1] or self.obj_init_pos[1] == self.obj_high[1]:
#                 d[0][1] = -d[0][1]
#             return d
#         elif not (state is None):
#             self.obj_init_pos = state
#             self._set_obj_xyz_move(self.obj_init_pos, target=self._target_pos)            
#         else:
#             while True:
#                 # print("obj", self.obj_init_pos)
#                 tmp = np.array([
#                     np.random.uniform(self.obj_low[0], self.obj_high[0]),  # 第一个元素：[-0.3, 0.3]
#                     np.random.uniform(self.obj_low[1], self.obj_high[1]),   # 第二个元素：[0.6, 0.8]
#                     np.random.uniform(self.obj_low[2], self.obj_high[2])      # 第三个元素：[0, 0.2]
#                 ])
#                 if np.linalg.norm(tmp - self.obj_init_pos) <= 0.223606797749979/8:
#                     self.obj_init_pos = tmp
#                     self._set_obj_xyz(self.obj_init_pos)
#                     break     


#     def _gripper_caging_reward(self, action, obj_position):
#         pad_success_margin = 0.05
#         x_z_success_margin = 0.005
#         obj_radius = 0.015
#         tcp = self.tcp_center
#         left_pad = self.get_body_com('leftpad')
#         right_pad = self.get_body_com('rightpad')
#         delta_object_y_left_pad = left_pad[1] - obj_position[1]
#         delta_object_y_right_pad = obj_position[1] - right_pad[1]
#         right_caging_margin = abs(abs(obj_position[1] - self.init_right_pad[1])
#             - pad_success_margin)
#         left_caging_margin = abs(abs(obj_position[1] - self.init_left_pad[1])
#             - pad_success_margin)

#         right_caging = reward_utils.tolerance(delta_object_y_right_pad,
#                                 bounds=(obj_radius, pad_success_margin),
#                                 margin=right_caging_margin,
#                                 sigmoid='long_tail',)
#         left_caging = reward_utils.tolerance(delta_object_y_left_pad,
#                                 bounds=(obj_radius, pad_success_margin),
#                                 margin=left_caging_margin,
#                                 sigmoid='long_tail',)

#         y_caging = reward_utils.hamacher_product(left_caging,
#                                                  right_caging)

#         # compute the tcp_obj distance in the x_z plane
#         tcp_xz = tcp + np.array([0., -tcp[1], 0.])
#         obj_position_x_z = np.copy(obj_position) + np.array([0., -obj_position[1], 0.])
#         tcp_obj_norm_x_z = np.linalg.norm(tcp_xz - obj_position_x_z, ord=2)

#         # used for computing the tcp to object object margin in the x_z plane
#         init_obj_x_z = self.obj_init_pos + np.array([0., -self.obj_init_pos[1], 0.])
#         init_tcp_x_z = self.init_tcp + np.array([0., -self.init_tcp[1], 0.])
#         tcp_obj_x_z_margin = np.linalg.norm(init_obj_x_z - init_tcp_x_z, ord=2) - x_z_success_margin

#         x_z_caging = reward_utils.tolerance(tcp_obj_norm_x_z,
#                                 bounds=(0, x_z_success_margin),
#                                 margin=tcp_obj_x_z_margin,
#                                 sigmoid='long_tail',)

#         gripper_closed = min(max(0, action[-1]), 1)
#         caging = reward_utils.hamacher_product(y_caging, x_z_caging)

#         gripping = gripper_closed if caging > 0.97 else 0.
#         caging_and_gripping = reward_utils.hamacher_product(caging,
#                                                             gripping)
#         caging_and_gripping = (caging_and_gripping + caging) / 2
#         return caging_and_gripping

#     def compute_reward(self, action, obs):
#         _TARGET_RADIUS = 0.05
#         tcp = self.tcp_center
#         obj = obs[4:7]
#         tcp_opened = obs[3]
#         target = self._target_pos

#         obj_to_target = np.linalg.norm(obj - target)
#         tcp_to_obj = np.linalg.norm(obj - tcp)
#         in_place_margin = (np.linalg.norm(self.obj_init_pos - target))

#         in_place = reward_utils.tolerance(obj_to_target,
#                                     bounds=(0, _TARGET_RADIUS),
#                                     margin=in_place_margin,
#                                     sigmoid='long_tail',)

#         object_grasped = self._gripper_caging_reward(action, obj)
#         in_place_and_object_grasped = reward_utils.hamacher_product(object_grasped,
#                                                                     in_place)
#         reward = in_place_and_object_grasped

#         if tcp_to_obj < 0.02 and (tcp_opened > 0) and (obj[2] - 0.01 > self.obj_init_pos[2]):
#             reward += 1. + 5. * in_place
#         if obj_to_target < _TARGET_RADIUS:
#             reward = 10.
#         return [reward, tcp_to_obj, tcp_opened, obj_to_target, object_grasped, in_place]


# if __name__ == '__main__':
#     a = SawyerPickPlaceEnvV2()
#     a.random_init = False
#     # a.reset()
#     print(dir(a.sim.data))
#     a.reset_model(set_xyz=True)
#     print(a._target_pos)
#     print(a.sim.data.site_xpos)
#     print(a.set_state(np.zeros(16,), np.zeros(15,)))






import numpy as np
from gym.spaces import Box
from scipy.spatial.transform import Rotation

from metaworld.envs import reward_utils
from metaworld.envs.asset_path_utils import full_v2_path_for
from metaworld.envs.mujoco.sawyer_xyz.sawyer_xyz_env import SawyerXYZEnv, _assert_task_is_set
from scipy.stats import beta




class SawyerPickPlaceLineEnvV2(SawyerXYZEnv):
    """
    Motivation for V2:
        V1 was very difficult to solve because the observation didn't say where
        to move after picking up the puck.
    Changelog from V1 to V2:
        - (7/7/20) Removed 3 element vector. Replaced with 3 element position
            of the goal (for consistency with other environments)
        - (6/15/20) Added a 3 element vector to the observation. This vector
            points from the end effector to the goal coordinate.
            i.e. (self._target_pos - pos_hand)
        - (6/15/20) Separated reach-push-pick-place into 3 separate envs.
    """
    def __init__(self):
        goal_low = (-0.1, 0.8, 0.05)
        goal_high = (0.1, 0.9, 0.3)
        hand_low = (-0.5, 0.40, 0.05)
        hand_high = (0.5, 1, 0.5)
        # obj_low = (-0.1, 0.6, 0.02)
        # obj_high = (0.1, 0.7, 0.02)
        # obj_low = (-0.3, 0.4, 0.02)
        # obj_high = (0.2, 0.9, 0.02)
        # tmp = [[-0.2, 0.5, 0.02], [-0.2, 0.8, 0.02], [0.1, 0.5, 0.02], [0.1, 0.8, 0.02]]
        obj_low = (-0.2, 0.5, 0.02)
        obj_high = (0.1, 0.8, 0.02)
        # obj_low = (-0.1, 0.55, 0.02)
        # obj_high = (0.1, 0.75, 0.02)
        # obj_low = (-0.2, 0.6, 0.02)
        # obj_high = (0.1, 0.7, 0.02)
        # obj_low = (-0.2, 0.55, 0.02)
        # obj_high = (0.1, 0.75, 0.02)
# 
        self.goal_low = goal_low
        self.goal_high = goal_high
        self.obj_low = obj_low
        self.obj_high = obj_high

        self.not_grasp_final = False

        if obj_low[1] == 0.55 and obj_low[0] == -0.2:#3*2
            self.obj_x = [-0.2, -0.125, -0.05, 0.025, 0.1]
            self.obj_y = [0.55, 0.64, 0.7, 0.75]
        elif obj_low[1] == 0.55 and obj_low[0] == -0.1:#2*2
            self.obj_x = [-0.1, -0.05, 0.0, 0.05, 0.1]
            self.obj_y = [0.55, 0.64, 0.7, 0.75]
        elif obj_low[1] == 0.6 and obj_low[0] == -0.2:#3*1
            self.obj_x = [-0.2, -0.125, -0.05, 0.025, 0.1]
            self.obj_y = [0.6, 0.63, 0.66, 0.7]
        elif obj_low[1] == 0.6 and obj_low[0] == -0.1:#3*1
            self.obj_x = [-0.1, -0.05, 0.0, 0.05, 0.1]
            self.obj_y = [0.6, 0.63, 0.66, 0.7]
        else:
            # self.obj_x = [-0.2, -0.125, -0.025, 0.05, 0.1]
            # self.obj_y = [0.5, 0.6, 0.7, 0.8]
            self.obj_x = [-0.18, -0.115, -0.05, 0.015, 0.08]
            self.obj_y = [0.52, 0.607, 0.693, 0.78]

        self.obj_x = [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.047432432432432434, 0.044864864864864865, 0.042297297297297295, 0.039729729729729726, 0.03716216216216216, 0.03459459459459459, 0.03202702702702702, 0.02945945945945945, 0.02689189189189188, 0.024324324324324312, 0.021756756756756743, 0.019189189189189174, 0.016621621621621605, 0.014054054054054037, 0.01148648648648647, 0.008918918918918902, 0.006351351351351335, 0.0037837837837837673, 0.0012162162162161995, -0.0013513513513513683, -0.003918918918918936, -0.0064864864864865035, -0.00905405405405407, -0.011621621621621638, -0.014189189189189206, -0.016756756756756773, -0.019324324324324342, -0.02189189189189191, -0.02445945945945948, -0.02702702702702705, -0.02959459459459462, -0.03216216216216219, -0.03472972972972976, -0.037297297297297326, -0.039864864864864895, -0.042432432432432464, -0.04500000000000003, -0.0475675675675676, -0.05013513513513517, -0.05270270270270274, -0.05527027027027031, -0.05783783783783788, -0.06040540540540545, -0.06297297297297301, -0.06554054054054058, -0.06810810810810815, -0.07067567567567572, -0.07324324324324329, -0.07581081081081086, -0.07837837837837842, -0.080945945945946, -0.08351351351351356, -0.08608108108108113, -0.0886486486486487, -0.09121621621621627, -0.09378378378378384, -0.09635135135135141, -0.09891891891891898, -0.10148648648648655, -0.10405405405405412, -0.10662162162162168, -0.10918918918918925, -0.11175675675675682, -0.11432432432432439, -0.11689189189189196, -0.11945945945945953, -0.1220270270270271, -0.12459459459459467, -0.12716216216216222, -0.1297297297297298, -0.13229729729729736, -0.13486486486486493, -0.1374324324324325, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.14000000000000007, -0.13227272727272735, -0.12454545454545463, -0.1168181818181819, -0.10909090909090918, -0.10136363636363646, -0.09363636363636374, -0.08590909090909102, -0.0781818181818183, -0.07045454545454558, -0.06272727272727285, -0.055000000000000125, -0.0472727272727274, -0.03954545454545467, -0.03181818181818194, -0.02409090909090921, -0.016363636363636483, -0.008636363636363756, -0.0009090909090910294, 0.006818181818181697, 0.014545454545454424, 0.022272727272727152, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.02999999999999988, 0.026938775510203964, 0.023877551020408047, 0.02081632653061213, 0.017755102040816213, 0.014693877551020296, 0.01163265306122438, 0.008571428571428463, 0.005510204081632545, 0.002448979591836627, -0.0006122448979592908, -0.0036734693877552085, -0.006734693877551126, -0.009795918367347044, -0.012857142857142963, -0.01591836734693888, -0.018979591836734797, -0.022040816326530713, -0.02510204081632663, -0.028163265306122547, -0.031224489795918464, -0.034285714285714385, -0.037346938775510305, -0.040408163265306225, -0.043469387755102146, -0.046530612244898066, -0.049591836734693986, -0.05265306122448991, -0.05571428571428583, -0.05877551020408175, -0.06183673469387767, -0.06489795918367358, -0.0679591836734695, -0.07102040816326541, -0.07408163265306132, -0.07714285714285724, -0.08020408163265315, -0.08326530612244906, -0.08632653061224498, -0.08938775510204089, -0.0924489795918368, -0.09551020408163272, -0.09857142857142863, -0.10163265306122454, -0.10469387755102046, -0.10775510204081637, -0.11081632653061228, -0.1138775510204082, -0.11693877551020411, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.12000000000000002, -0.11187500000000003, -0.10375000000000004, -0.09562500000000004, -0.08750000000000005, -0.07937500000000006, -0.07125000000000006, -0.06312500000000007, -0.05500000000000008, -0.04687500000000008, -0.03875000000000009, -0.030625000000000093, -0.022500000000000096, -0.0143750000000001, -0.006250000000000103, 0.0018749999999998941, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.009999999999999891, 0.005925925925925818, 0.0018518518518517452, -0.0022222222222223276, -0.0062962962962964004, -0.010370370370370474, -0.014444444444444548, -0.01851851851851862, -0.022592592592592695, -0.02666666666666677, -0.030740740740740843, -0.034814814814814916, -0.03888888888888899, -0.04296296296296306, -0.04703703703703713, -0.0511111111111112, -0.05518518518518527, -0.05925925925925934, -0.06333333333333341, -0.06740740740740749, -0.07148148148148156, -0.07555555555555564, -0.07962962962962972, -0.0837037037037038, -0.08777777777777787, -0.09185185185185195, -0.09592592592592603, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.1000000000000001, -0.09250000000000011, -0.08500000000000012, -0.07750000000000012, -0.07000000000000013, -0.06250000000000014, -0.05500000000000014, -0.04750000000000014, -0.04000000000000014, -0.03250000000000014, -0.025000000000000144, -0.017500000000000147, -0.010000000000000151, -0.010000000000000151, -0.010000000000000151, -0.010000000000000151, -0.010000000000000151, -0.01350000000000015, -0.01700000000000015, -0.02050000000000015, -0.02400000000000015, -0.02750000000000015, -0.03100000000000015, -0.03450000000000015, -0.038000000000000145, -0.04150000000000014, -0.04500000000000014, -0.04850000000000013, -0.05200000000000013, -0.055500000000000126, -0.05900000000000012, -0.06250000000000012, -0.06600000000000013, -0.06950000000000013, -0.07300000000000013, -0.07650000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.08000000000000014, -0.06333333333333348, -0.046666666666666815, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.030000000000000155, -0.03600000000000015, -0.04200000000000014, -0.04800000000000013, -0.054000000000000124, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116, -0.060000000000000116]
        self.obj_y = [0.75, 0.7428571428571429, 0.7357142857142858, 0.7285714285714286, 0.7214285714285715, 0.7142857142857144, 0.7071428571428573, 0.7000000000000002, 0.6928571428571431, 0.6857142857142859, 0.6785714285714288, 0.6714285714285717, 0.6642857142857146, 0.6571428571428575, 0.6500000000000004, 0.6428571428571432, 0.6357142857142861, 0.628571428571429, 0.6214285714285719, 0.6142857142857148, 0.6071428571428577, 0.6000000000000005, 0.5928571428571434, 0.5857142857142863, 0.5785714285714292, 0.5714285714285721, 0.564285714285715, 0.5571428571428578, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.5500000000000007, 0.553272727272728, 0.5565454545454553, 0.5598181818181827, 0.56309090909091, 0.5663636363636373, 0.5696363636363646, 0.5729090909090919, 0.5761818181818192, 0.5794545454545466, 0.5827272727272739, 0.5860000000000012, 0.5892727272727285, 0.5925454545454558, 0.5958181818181831, 0.5990909090909105, 0.6023636363636378, 0.6056363636363651, 0.6089090909090924, 0.6121818181818197, 0.615454545454547, 0.6187272727272743, 0.6220000000000017, 0.625272727272729, 0.6285454545454563, 0.6318181818181836, 0.6350909090909109, 0.6383636363636382, 0.6416363636363656, 0.6449090909090929, 0.6481818181818202, 0.6514545454545475, 0.6547272727272748, 0.6580000000000021, 0.6612727272727295, 0.6645454545454568, 0.6678181818181841, 0.6710909090909114, 0.6743636363636387, 0.677636363636366, 0.6809090909090934, 0.6841818181818207, 0.687454545454548, 0.6907272727272753, 0.6940000000000026, 0.6972727272727299, 0.7005454545454572, 0.7038181818181846, 0.7070909090909119, 0.7103636363636392, 0.7136363636363665, 0.7169090909090938, 0.7201818181818211, 0.7234545454545485, 0.7267272727272758, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7300000000000031, 0.7240740740740772, 0.7181481481481513, 0.7122222222222254, 0.7062962962962995, 0.7003703703703736, 0.6944444444444478, 0.6885185185185219, 0.682592592592596, 0.6766666666666701, 0.6707407407407442, 0.6648148148148183, 0.6588888888888924, 0.6529629629629665, 0.6470370370370406, 0.6411111111111147, 0.6351851851851888, 0.629259259259263, 0.6233333333333371, 0.6174074074074112, 0.6114814814814853, 0.6055555555555594, 0.5996296296296335, 0.5937037037037076, 0.5877777777777817, 0.5818518518518558, 0.57592592592593, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.5700000000000041, 0.573888888888893, 0.5777777777777819, 0.5816666666666709, 0.5855555555555598, 0.5894444444444488, 0.5933333333333377, 0.5972222222222267, 0.6011111111111156, 0.6050000000000045, 0.6088888888888935, 0.6127777777777824, 0.6166666666666714, 0.6205555555555603, 0.6244444444444492, 0.6283333333333382, 0.6322222222222271, 0.6361111111111161, 0.640000000000005, 0.643888888888894, 0.6477777777777829, 0.6516666666666718, 0.6555555555555608, 0.6594444444444497, 0.6633333333333387, 0.6672222222222276, 0.6711111111111165, 0.6750000000000055, 0.6788888888888944, 0.6827777777777834, 0.6866666666666723, 0.6905555555555613, 0.6944444444444502, 0.6983333333333391, 0.7022222222222281, 0.706111111111117, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.710000000000006, 0.7029411764705942, 0.6958823529411824, 0.6888235294117706, 0.6817647058823588, 0.674705882352947, 0.6676470588235353, 0.6605882352941235, 0.6535294117647117, 0.6464705882352999, 0.6394117647058881, 0.6323529411764763, 0.6252941176470646, 0.6182352941176528, 0.611176470588241, 0.6041176470588292, 0.5970588235294174, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5900000000000056, 0.5971428571428627, 0.6042857142857199, 0.611428571428577, 0.6185714285714341, 0.6257142857142912, 0.6328571428571483, 0.6400000000000055, 0.6471428571428626, 0.6542857142857197, 0.6614285714285768, 0.6685714285714339, 0.675714285714291, 0.6828571428571482, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6900000000000053, 0.6700000000000053, 0.6500000000000052, 0.6300000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6100000000000052, 0.6140000000000052, 0.6180000000000052, 0.6220000000000052, 0.6260000000000052, 0.6300000000000052, 0.6340000000000052, 0.6380000000000052, 0.6420000000000052, 0.6460000000000052, 0.6500000000000052, 0.6540000000000052, 0.6580000000000052, 0.6620000000000053, 0.6660000000000053, 0.6700000000000053, 0.6700000000000053, 0.6700000000000053, 0.6700000000000053, 0.666666666666672, 0.6633333333333387, 0.6600000000000054, 0.6566666666666721, 0.6533333333333388, 0.6500000000000055, 0.6466666666666722, 0.6433333333333389, 0.6400000000000056, 0.6366666666666723, 0.633333333333339, 0.6300000000000057, 0.6300000000000057, 0.6300000000000057, 0.6300000000000057, 0.6300000000000057, 0.6300000000000057, 0.6309090909090965, 0.6318181818181874, 0.6327272727272782, 0.6336363636363691, 0.63454545454546, 0.6354545454545508, 0.6363636363636417, 0.6372727272727325, 0.6381818181818234, 0.6390909090909143, 0.6400000000000051, 0.640909090909096, 0.6418181818181868, 0.6427272727272777, 0.6436363636363686, 0.6445454545454594, 0.6454545454545503, 0.6463636363636411, 0.647272727272732, 0.6481818181818229, 0.6490909090909137, 0.6500000000000046]

        self.obj_x = self.obj_x[:455]
        self.obj_y = self.obj_y[:455]

        self.initial_static_x = [0.03202702702702702, -0.05783783783783788, -0.14000000000000007, -0.14000000000000007, -0.0009090909090910294, 0.017755102040816213, -0.08938775510204089, -0.12000000000000002, 0.009999999999999891, -0.09592592592592603, -0.02400000000000015, -0.030000000000000155, -0.060000000000000116]
        self.initial_static_y = [0.5500000000000007, 0.5500000000000007, 0.5598181818181827, 0.6743636363636387, 0.7300000000000031, 0.5700000000000041, 0.5700000000000041, 0.6672222222222276, 0.6535294117647117, 0.5900000000000056, 0.6100000000000052, 0.666666666666672, 0.647272727272732]

        self.grasp_static_x, self.grasp_static_y = [], []
        for i in range(len(self.obj_x)):
            # if i % 35 == 34:
            if (i+1) % 5 == 0:
                self.grasp_static_x.append(self.obj_x[i])
                self.grasp_static_y.append(self.obj_y[i])


        self.goal_points = [
            (0, 0.85, 0.2)
        ]

        self.hand_x = [-0.28, -0.2, -0.14, -0.08, -0.02]
        self.hand_y = [0.52, 0.54, 0.56, 0.58]
        self.hand_z = [0.22, 0.26, 0.3, 0.34, 0.38]

        self.obj_initial_cnt = 0

        super().__init__(
            self.model_name,
            hand_low=hand_low,
            hand_high=hand_high,
        )

        self.move_object = True
        self.retarget = False

        self.init_config = {
            'obj_init_angle': .3,
            'obj_init_pos': np.array([0, 0.6, 0.02]),
            'hand_init_pos': np.array([0, .6, .2]),
        }

        self.goal = np.array([0.1, 0.8, 0.2])

        self.obj_init_angle = self.init_config['obj_init_angle']
        self.obj_init_pos = self.init_config['obj_init_pos']
        self.hand_init_pos = self.init_config['hand_init_pos']
        self._target_pos = self.goal.copy()

        self._random_reset_space = Box(
            np.hstack((obj_low, goal_low)),
            np.hstack((obj_high, goal_high)),
        )
        self.goal_space = Box(np.array(goal_low), np.array(goal_high))


        self.num_resets = 0
        # self.obj_init_pos = None

    @property
    def model_name(self):
        return full_v2_path_for('sawyer_xyz/sawyer_pick_place_v2.xml')

    @_assert_task_is_set
    def evaluate_state(self, obs, action):
        obj = obs[4:7]

        reward, tcp_to_obj, tcp_open, obj_to_target, grasp_reward, in_place_reward = self.compute_reward(action, obs)
        success = float(obj_to_target <= 0.07)
        near_object = float(tcp_to_obj <= 0.03)
        grasp_success = float(self.touching_main_object and (tcp_open > 0) and (obj[2] - 0.02 > self.obj_init_pos[2]))
        info = {
            'success': success,
            'near_object': near_object,
            'grasp_success': grasp_success,
            'grasp_reward': grasp_reward,
            'in_place_reward': in_place_reward,
            'obj_to_target': obj_to_target,
            'unscaled_reward': reward
        }

        # print(obs.shape, action.shape, info)

        return reward, info

    @property
    def _get_id_main_object(self):
        return self.unwrapped.model.geom_name2id('objGeom')

    def _get_pos_objects(self):
        return self.get_body_com('obj')

    def _get_quat_objects(self):
        return Rotation.from_matrix(self.data.get_geom_xmat('objGeom')).as_quat()

    def fix_extreme_obj_pos(self, orig_init_pos):
        # This is to account for meshes for the geom and object are not
        # aligned. If this is not done, the object could be initialized in an
        # extreme position
        diff = self.get_body_com('obj')[:2] - \
               self.get_body_com('obj')[:2]
        adjusted_pos = orig_init_pos[:2] + diff
        # The convention we follow is that body_com[2] is always 0,
        # and geom_pos[2] is the object height
        return [
            adjusted_pos[0],
            adjusted_pos[1],
            self.get_body_com('obj')[-1]
        ]

    def reset_model(self, set_xyz=False):

        self._reset_hand()

        if set_xyz:
        # if False:
            self._target_pos = self.goal.copy()
            # print(type(self._target_pos), type(self.obj_init_pos))
            # self.obj_init_pos = self.fix_extreme_obj_pos(self.init_config['obj_init_pos'])
            self.obj_init_angle = self.init_config['obj_init_angle']

            # print("into set xyz")

            if self.random_init:
                goal_pos = self._get_state_rand_vec()
                # goal_pos[1] = 0.5 + (0.8 - 0.5) * beta.rvs(1, 3, size=1)[0]
                self._target_pos = goal_pos[3:]
                while np.linalg.norm(goal_pos[:2] - self._target_pos[:2]) < 0.15:
                    goal_pos = self._get_state_rand_vec()
                    # goal_pos[1] = 0.5 + (0.8 - 0.5) * beta.rvs(1, 3, size=1)[0]
                    self._target_pos = goal_pos[3:]
                self._target_pos = np.array(list(self.goal_points[0]))
                self.obj_init_pos = goal_pos[:3]
                self.hand_init_pos = np.random.uniform(low=np.array([0, 0.5, 0.4]), high=np.array([0.3, 0.6, 0.4]))
                print("!")

            else:
                # self.obj_init_pos = [self.obj_x[((self.obj_initial_cnt-1)//3)%5], self.obj_y[((self.obj_initial_cnt-1)//3)%4], 0.02]
                # self._target_pos = np.array(list(self.goal_points[((self.obj_initial_cnt-1)//3)%20]))
                self.obj_init_pos = [self.grasp_static_x[self.obj_initial_cnt%91], self.grasp_static_y[self.obj_initial_cnt%91], 0.02]
                self._target_pos = np.array(list(self.goal_points[0]))
                self.hand_x = [0.02, 0.08, 0.15, 0.22, 0.28]
                self.hand_y = [0.52, 0.54, 0.56, 0.58]
                self.hand_init_pos = np.array([self.hand_x[self.obj_initial_cnt%5], self.hand_y[self.obj_initial_cnt%4], 0.4])

                self.obj_initial_cnt += 1



        else:
            self._target_pos = self._target_pos
            # self._target_pos = self.goal.copy()
            # print(type(self._target_pos), type(self.obj_init_pos))
            self.obj_init_pos = self.fix_extreme_obj_pos(self.obj_init_pos)
            self.obj_init_angle = self.init_config['obj_init_angle']

        self.init_tcp = self.tcp_center
        self.init_left_pad = self.get_body_com('leftpad')
        self.init_right_pad = self.get_body_com('rightpad')
        self._set_obj_xyz(self.obj_init_pos)
        self.num_resets += 1

        return self._get_obs()


    # def reset_model(self, set_xyz=False):
    #     self._reset_hand()
    #     self._target_pos = self.goal.copy()
    #     self.obj_init_pos = self.fix_extreme_obj_pos(self.init_config['obj_init_pos'])
    #     self.obj_init_angle = self.init_config['obj_init_angle']

    #     if self.random_init:
    #         goal_pos = self._get_state_rand_vec()
    #         self._target_pos = goal_pos[3:]
    #         while np.linalg.norm(goal_pos[:2] - self._target_pos[:2]) < 0.15:
    #             goal_pos = self._get_state_rand_vec()
    #             self._target_pos = goal_pos[3:]
    #         self._target_pos = goal_pos[-3:]
    #         self.obj_init_pos = goal_pos[:3]
    #         self.init_tcp = self.tcp_center
    #         self.init_left_pad = self.get_body_com('leftpad')
    #         self.init_right_pad = self.get_body_com('rightpad')

    #     self._set_obj_xyz(self.obj_init_pos)
    #     self.num_resets += 1

    #     return self._get_obs()



    def set_new_target(self, state=None, v=None, d=None):
        # goal_low = (-0.1, 0.8, 0.05)
        # goal_high = (0.1, 0.9, 0.3)
        # hand_low = (-0.5, 0.40, 0.05)
        # hand_high = (0.5, 1, 0.5)
        # obj_low = (-0.1, 0.6, 0.02)
        # obj_high = (0.1, 0.7, 0.02)
        print(state)
        print(state!=None)
        if not (state is None):
            self._target_pos = state
            return
        while True:
            print("reset target", self._target_pos)
            tmp = np.array([
                np.random.uniform(self.goal_low[0], self.goal_high[0]),  # 第一个元素：[-0.3, 0.3]
                np.random.uniform(self.goal_low[1], self.goal_high[1]),   # 第二个元素：[0.6, 0.8]
                np.random.uniform(self.goal_low[2], self.goal_high[2])      # 第三个元素：[0, 0.2]
            ])
            # if np.linalg.norm(tmp - self._target_pos) >= 0.1:
            if np.linalg.norm(tmp - self.obj_init_pos) >= 0.33541019662496846/2:# and np.linalg.norm(tmp - self._target_pos) >= 0.1:
            # if tmp[0] - self.obj_init_pos[0] >= -0.15:# and np.linalg.norm(tmp - self._target_pos) >= 0.1:
                self._target_pos = tmp
                break


    def set_new_obj(self, state=None, v=0, d=None):
        if v != 0:
            self.obj_init_pos = np.clip(self.obj_init_pos+d[0]*v, self.obj_low, self.obj_high)
            # print("target, ", self._target_pos)
            self._set_obj_xyz_move(self.obj_init_pos, target=self._target_pos)
            # print(d)
            if self.obj_init_pos[0] == self.obj_low[0] or self.obj_init_pos[0] == self.obj_high[0]:
                d[0][0] = -d[0][0]
            if self.obj_init_pos[1] == self.obj_low[1] or self.obj_init_pos[1] == self.obj_high[1]:
                d[0][1] = -d[0][1]
            return d
        elif not (state is None):
            # print(state)
            self.obj_init_pos = np.array([state[0], state[1], 0.02])
            self._set_obj_xyz_move(self.obj_init_pos, target=self._target_pos)            
        else:
            while True:
                # print("obj", self.obj_init_pos)
                tmp = np.array([
                    np.random.uniform(self.obj_low[0], self.obj_high[0]),  # 第一个元素：[-0.3, 0.3]
                    np.random.uniform(self.obj_low[1], self.obj_high[1]),   # 第二个元素：[0.6, 0.8]
                    np.random.uniform(self.obj_low[2], self.obj_high[2])      # 第三个元素：[0, 0.2]
                ])
                if np.linalg.norm(tmp - self.obj_init_pos) <= 0.223606797749979/8:
                    self.obj_init_pos = tmp
                    self._set_obj_xyz(self.obj_init_pos)
                    break     


    def _gripper_caging_reward(self, action, obj_position):
        pad_success_margin = 0.05
        x_z_success_margin = 0.005
        obj_radius = 0.015
        tcp = self.tcp_center
        left_pad = self.get_body_com('leftpad')
        right_pad = self.get_body_com('rightpad')
        delta_object_y_left_pad = left_pad[1] - obj_position[1]
        delta_object_y_right_pad = obj_position[1] - right_pad[1]
        right_caging_margin = abs(abs(obj_position[1] - self.init_right_pad[1])
            - pad_success_margin)
        left_caging_margin = abs(abs(obj_position[1] - self.init_left_pad[1])
            - pad_success_margin)

        right_caging = reward_utils.tolerance(delta_object_y_right_pad,
                                bounds=(obj_radius, pad_success_margin),
                                margin=right_caging_margin,
                                sigmoid='long_tail',)
        left_caging = reward_utils.tolerance(delta_object_y_left_pad,
                                bounds=(obj_radius, pad_success_margin),
                                margin=left_caging_margin,
                                sigmoid='long_tail',)

        y_caging = reward_utils.hamacher_product(left_caging,
                                                 right_caging)

        # compute the tcp_obj distance in the x_z plane
        tcp_xz = tcp + np.array([0., -tcp[1], 0.])
        obj_position_x_z = np.copy(obj_position) + np.array([0., -obj_position[1], 0.])
        tcp_obj_norm_x_z = np.linalg.norm(tcp_xz - obj_position_x_z, ord=2)

        # used for computing the tcp to object object margin in the x_z plane
        init_obj_x_z = self.obj_init_pos + np.array([0., -self.obj_init_pos[1], 0.])
        init_tcp_x_z = self.init_tcp + np.array([0., -self.init_tcp[1], 0.])
        tcp_obj_x_z_margin = np.linalg.norm(init_obj_x_z - init_tcp_x_z, ord=2) - x_z_success_margin

        x_z_caging = reward_utils.tolerance(tcp_obj_norm_x_z,
                                bounds=(0, x_z_success_margin),
                                margin=tcp_obj_x_z_margin,
                                sigmoid='long_tail',)

        gripper_closed = min(max(0, action[-1]), 1)
        caging = reward_utils.hamacher_product(y_caging, x_z_caging)

        gripping = gripper_closed if caging > 0.97 else 0.
        caging_and_gripping = reward_utils.hamacher_product(caging,
                                                            gripping)
        caging_and_gripping = (caging_and_gripping + caging) / 2
        return caging_and_gripping

    def compute_reward(self, action, obs):
        _TARGET_RADIUS = 0.05
        tcp = self.tcp_center
        obj = obs[4:7]
        tcp_opened = obs[3]
        target = self._target_pos

        obj_to_target = np.linalg.norm(obj - target)
        tcp_to_obj = np.linalg.norm(obj - tcp)
        in_place_margin = (np.linalg.norm(self.obj_init_pos - target))

        in_place = reward_utils.tolerance(obj_to_target,
                                    bounds=(0, _TARGET_RADIUS),
                                    margin=in_place_margin,
                                    sigmoid='long_tail',)

        object_grasped = self._gripper_caging_reward(action, obj)
        in_place_and_object_grasped = reward_utils.hamacher_product(object_grasped,
                                                                    in_place)
        reward = in_place_and_object_grasped

        if tcp_to_obj < 0.02 and (tcp_opened > 0) and (obj[2] - 0.01 > self.obj_init_pos[2]):
            reward += 1. + 5. * in_place
        if obj_to_target < _TARGET_RADIUS:
            reward = 10.
        return [reward, tcp_to_obj, tcp_opened, obj_to_target, object_grasped, in_place]


if __name__ == '__main__':
    a = SawyerPickPlaceEnvV2()
    a.random_init = False
    # a.reset()
    print(dir(a.sim.data))
    a.reset_model(set_xyz=True)
    print(a._target_pos)
    print(a.sim.data.site_xpos)
    print(a.set_state(np.zeros(16,), np.zeros(15,)))